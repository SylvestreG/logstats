# Requirements

## dependencies

### MacOsX

You need this dependencies for building on MacOsX :

* conan
    * ```brew install conan``` if you are using brew
* cmake
    * ```brew install cmake``` if you are using brew
* a decent C compiler. Clang must comes with XCode, if you do not have XCode install it from the App Store.
* make/automake/autoconf
    * ```brew instal make automake autoconf```
* a good terminal like iterm2
    * ```brew instal --cask iterm2```
* bison/flex/m4/gettext
    * ```brew install bison flex m4 gettext```
    * **follow** instruction from brew to update your path ``` bison --version```
        should be greater than 3.0. Macos ship with an old bison.
    * for me a path update was ```export PATH="/usr/local/opt/bison/bin:$PATH"``` and ```export PATH="/usr/local/opt/flex/bin:$PATH"```

if you already have these packages installed by brew in the past, update them to a recent version

### Linux

For the moment I only try on ArchLinux. Here is an list of dependencies needed.

* conan, install pip3 and install it from pip after that
    * ```pip3 install conan```
* cmake
    * ```pacman -S cmake``` on ArchLinux
    * ```apt-get install cmake``` on debian-like
* make / g++
    * ```pacman -S make g++``` on ArchLinux
    * ```apt-get install build-essential g++``` on debian-like
* a good terminal like Tilix
    * ```pacman -S tilix``` on ArchLinux
    * ```apt-get install tilix``` on debian-like
* bison/flex/m4/ncurses can be necessary on linux
    * ```pacman -S bison flex m4``` on ArchLinux
    * ```apt-get install libncurses-dev bison flex m4``` on debian-like

## how to build

the following commands needs to be done inside the project directory.

First we need to create a build directory :

```bash
mkdir -p build
cd build
```

After that we need to launch cmake :

```bash
cmake ..
```

This command can take quite some time because it will invoke **conan** the npm like
package manager for c++. So it can compile quite a lot of stuff... When this step is
finish you can build the project using make:

```bash
make -j
```

### cheating using docker ###

If your build failed on your computer you can build it with docker :
```bash
docker build -t clf .
```

this will create a docker image containing the build of the differents binaries.

to launch them you will need to map the directory containing your files in the same path on the docker images.

if you want to launch clfMonitor with a file from /tmp do :

```bash
docker run -v /tmp:/tmp -it clf /bin/bash -c "TERM=xterm-256color clfMonitor /tmp/toto"
```

and if you want to launch a scenarioPlayer do :

```bash
cp -fr conf/* /tmp/.
cp -fr data/* /tmp/.
docker run -v /tmp:/tmp -it clf /bin/bash -c "TERM=xterm-256color scenarioPlayer -o /tmp/toto -i /tmp/access.log -c /tmp/scenarioConfig.json"
```

Beware all the file you need (config/input/output) must be in the directory mounted by your volume (here ```/tmp```).

### build errors ###

If you launch a build with a bad version of bison on your path, you will have a build error.
To fix it you need to update your path. After that remove your build folder and restart the build.

## What are the different binaries

All the binaries are generated by the build phase. you will find them in the
build/bin directory. 4 binaries should be generated.

### clfMonitor

The clfMonitor. This program parse a clf log file and output interesting
information about it.

here is the usage of clfMonitor :
```bash
./clfMonitor inputFile [-c configFile]
```

Here is a conf for clfMonitor :
```json
{
"alertTimeMs": 5000,
"bufferSizeBytes": 4096,
"consumerThreadsNumber": 4,
"debugEnabled": true,
"refreshTimeMs": 3000,
"alertThresholdNumber" : 10
}
```
* alertTimeMs is the timeWindow in ms where we look for a thresoldNumber of lines (500ms < x < 65536)
* bufferSizeBytes is Max ReadSize we are using in io ( 100 < x < 65536ms)
* consumerThreadsNumber is the nb of parsing thread ( 1 < x < 256)
* debugEnabled tell if we output parser debug output in parser.log and lexer.log
* refreshTimeMs is the time in ms between each refresh of monitoring data ( 1000ms < x < 65536ms)
* alertThresholdNumber is the thresold number to create an alert ( 1 < x < 65536ms)

### clfGenerator

The clfGenerator generator will generate an *N* log lines every *T* interval of 
times into the output file . The behaviour of this program is defined by its config file.

Here is the usage of clfGenerator :
```bash
./clfGenerator output.log [-c config.json]
```

Here is a conf for clfGenerator :
```json
{
  "requestNumber": 1000,
  "delayBetweenRequestMs": 10,
  "ipAddr": "127.0.0.1",
  "userIdentifier": "userIdentifier",
  "userId": "syl",
  "verb": "PUT",
  "path" : "/api/index.html",
  "httpVersion" :  "HTTP/1.0",
  "httpStatus" : 200,
  "size" : 42424
}
```

* requestNumber is the number of requests that are going to be sent
* delayBetweenRequestMs is the number of ms we wait between each request

### scenarioPlayer

The scenarioPlayer will take an input file and will give each line to an
output file following a scenario defined in the config files.

Here is the usage of clfGenerator :
```bash
./scenarioPlayer -i input.log -o output.log [-c config.json]
```

Here is a conf for scenario player :
```json
{
  "scenarios": [
    [12, 1000],
    [1000, 5],
    [20, 100],
    [1000, 5],
    [10, 5],
    [1000, 5],
    [5, 2000],
    [1000, 5],
    [100, 500]
  ]
}
```
* scenario is an array of scenarios. A scenario is a tuple of value
  containing the nb of requests and the time to wait between each request. 
  Here 12 request of 1sec, 1000 request of 5ms etc...

### units

This is for development purpose. It some unit test of some part of the code.

### conf/data Files

You can find examples of config files in the **conf** folder in the project root dir. you
can find a exemple of input to give to scenarioPlayer in the **data** folder.

# Architecture

## Timers

We use two boost::asio timers in core :
* _alertOffTimer
* _refreshTimer

```alertOffTimer``` is a tick that will comes every 50ms. Its aim is too see
if the end of an high traffic event happen.

```refreshTimer``` is used to refresh the current window of the monitoring.

## Data

We split the data into two structures that has quite the same fields :
- a monitoring window structure named ***MonitoringData***
- a monitoring global structure named ***GlobalMonitoringData***

The **first** one will be updated at each log line inside the current window and will 
be reset at the end of the window. The **second** one will be updated on each log line.

Here is the data inside both structure.
```c++
  uint64_t _totalLines{0};          // nb parsed line
  uint64_t _totalValidLines{0};     // nb parser line with success
  uint64_t _totalSize{0};           // sum of each line http size

  std::unordered_map<boost::beast::http::verb, uint64_t> _verbMap;     //hashtable with verb as key, nb occurance as value
  std::unordered_map<boost::beast::http::status, uint64_t> _statusMap; //hashtable with status as key, nb occurance as value
  std::unordered_map<std::string, uint64_t> _pathMap;                  //hashtable with path as key, nb occurance as value
  std::array<uint64_t, 3> _versionArray;                               //array with nb with nb occurance of http version (0 => 1.0, 1 => 1.1 => unknow)
```

the current window also have theses map that will be filled at the end of the current window
```c++
  std::map<uint64_t, boost::beast::http::verb> _orderedVerb;
  std::map<uint64_t, boost::beast::http::status> _orderedStatus;
  std::map<uint64_t, std::string> _orderedPath;
```
The map is ordered by its key. It will allow us to print the verb/status/path in order of 
 times we see them.

## Global Thread architecture

```
   1 th                    1th                   x th
###########            ###########            ###########
#  File   #    ____\  #   Buffer #    ____\   #   clf   #
# Watcher #    ____    #Splitter #    ____    #  Parser #
###########        //  ###########        //  ###########
                                                  | |
                                                  | | set Data
                                                \| |//
                                               #########
                                               #       #
                                               #   Ui  #
                                               #       #
                                               #########
```

Here is the principal data flow into clfMonitor

* The FileWatcher thread take care of i/o :
    * looking for file changes
    * reading ios
    * tag buffer with timestamp and give them to the splitter
* The bufferSplitter thread take care of preparing lines for parser.
    * get buffers from fileWatcher
    * split buffers into single lines
    * call core **getDataFromSplitter** for each line
        * **getDataFromSplitter** will send the buffer to a thread pool for parsing data.
* clfParser parse entry and gather data
    * it is called in a thread pool of **consumerThreadsNumber** threads
    * all parsing is lockfree
    * data gathering is under lock (because ui access to these datas)

## Core

Core is like an orchestrator, it will call all the parts of this program to works well.

## Parsing

For parsing we use a flex/bison parser. The grammar try to fit the common log format.

This parser is intended to parser only one line at a time.

## Ui

Ui code is present into *ui* code. It use imtui library (external/imtui) to display stuff 
on the terminal.

# Limitations

## parsing

When some part of the message are not handled by the grammar the message is dropped.

## file rotate

File rotate is not supported yet, so if the file we are looking is moved or created again
clfMonitoring will not show further line written in this file.

## Improvements

### Move threads to service.
If we want to be elastic we could move each thread (except the io one) to a *micro service* using
a communication bus like ```zeromq```. It will allow us to give the job to local/remote workers.

### A tickless scheduler.
For the moment we use a tick(every 50ms) for looking for the end of an alert period.
We could remove this tick and set a timer to wait until the end of the alert period 
(updating this timer if a new lines come before the trig).

### An api to get stats
The data could easily provide an api to fetching data. Something like grpc or
an api rest. Doing that will allow us to remove the ui from clfMonitor.


# troubleshooting

## Click on ui
Sometimes on MacOs imtui need double click to understand clicks...

## black screen

When you have a black screen launching clfMonitor try to launch it like that :
```bash
TERM=xterm-256color ./clfMonitor
```

This will set the good term value that is needed by clfMonitor.

## build fail

try the docker version.